{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This, is Hermes Hermes is a tiny MQTT broker written in Go. It is inspired by several mature messaging systems such as NATS, Kafka, ActiveMQ etc. Vision Messaging should be easy Developers should be able to onboard Hermes and start writing code without the need to unlearn their current messaging experience. Hermes will be cloud compatible, but you don't need to have Kubernetes running. You will be able to run Hermes anywhere from a Raspberry Pi, to a traditional Linux Desktop, a gigantic public cloud machine, an IBM-Z server, and of course, Kubernetes. Messaging should be based on open standards When messaging systems are built on open standards, it grows the ecosystem instead of dividing it. Hermes will always be based on multiple open standards and transports. Knowledge is best when shared Hermes was born out of boredom during the COVID-19 pandemic, and the initial directions were discussed over a Reddit post . All discussions, and development are done on GitHub. There will never be an enterprise , or premium flavor of Hermes. It is however, MIT Licensed - you are free to use it however you wish to. Baby Yoda eating cookies is cute","title":"Home"},{"location":"#this-is-hermes","text":"Hermes is a tiny MQTT broker written in Go. It is inspired by several mature messaging systems such as NATS, Kafka, ActiveMQ etc.","title":"This, is Hermes"},{"location":"#vision","text":"","title":"Vision"},{"location":"#messaging-should-be-easy","text":"Developers should be able to onboard Hermes and start writing code without the need to unlearn their current messaging experience. Hermes will be cloud compatible, but you don't need to have Kubernetes running. You will be able to run Hermes anywhere from a Raspberry Pi, to a traditional Linux Desktop, a gigantic public cloud machine, an IBM-Z server, and of course, Kubernetes.","title":"Messaging should be easy"},{"location":"#messaging-should-be-based-on-open-standards","text":"When messaging systems are built on open standards, it grows the ecosystem instead of dividing it. Hermes will always be based on multiple open standards and transports.","title":"Messaging should be based on open standards"},{"location":"#knowledge-is-best-when-shared","text":"Hermes was born out of boredom during the COVID-19 pandemic, and the initial directions were discussed over a Reddit post . All discussions, and development are done on GitHub. There will never be an enterprise , or premium flavor of Hermes. It is however, MIT Licensed - you are free to use it however you wish to.","title":"Knowledge is best when shared"},{"location":"#baby-yoda-eating-cookies-is-cute","text":"","title":"Baby Yoda eating cookies is cute"},{"location":"about/","text":"Hermes is a tiny MQTT broker written in Go with a focus on minimalism. Hence, the minimal content here, too.","title":"About"},{"location":"configuration/","text":"Hermes can be configured via a custom JSON configuration, and the path can be passed over via the CONFIG_FILE_PATH environment variable. The current JSON schema to be adhered to, can be found at c16a/hermes:/config/config.go When running on Docker or Kubernetes, this file should be mounted as a volume.","title":"Configuration"},{"location":"docker-build/","text":"Hermes uses a multi stage docker build for hermetic builds, while creating a minimal image. Hence, please ensure you use Docker v17.05 or newer. git clone https://github.com/c16a/hermes.git cd hermes docker build -t hermes-app . Running the image docker run -p 4000 :4000 -v $pwd /config.json:/app/config.json hermes-app The above example assumes that the TCP server has been configured to listen on port 4000. In case that is configured to another port, please configure the docker exposed port accordingly. SELinux policies When using Docker on a host with SELinux enabled, the container is denied access to certain parts of host file system unless it is run in privileged mode. To resolve this, you can use a named volume # Create a docker volume and map it to /tmp/hermes on the host docker volume create --driver local --opt type = none --opt device = /tmp/hermes --opt o = bind hermes_volume # Ensure /tmp/hermes/config.json has the required broker configuration # Use the above created hermes_volume to mount the config file into the container docker run -p 4000 :4000 -e CONFIG_FILE_PATH = /tmp/hermes/config.json --mount source = hermes_volume,target = /tmp/hermes hermes Please note that however, you place your config.json in the /tmp directory, SELinux does not restrict you access when you use a direct volume mapping. # This won't work with SELinux enabled docker run -p 4000 :4000 -e CONFIG_FILE_PATH = /tmp/hermes/config.json -v /home/user/config.json:/tmp/hermes/config.json hermes # This will work docker run -p 4000 :4000 -e CONFIG_FILE_PATH = /tmp/hermes/config.json -v /tmp/hermes/config.json:/tmp/hermes/config.json hermes The Configuration section has more details on which attributes of the broker can be configured. Running in Compose mode Create the named volume hermes_volume . # Create a docker volume and map it to /tmp/hermes on the host docker volume create --driver local --opt type = none --opt device = /tmp/hermes --opt o = bind hermes_volume Reference the named volume for the service version : \"3.9\" services : broker : build : context : . environment : CONFIG_FILE_PATH : \"/tmp/hermes/config.json\" volumes : - hermes_volume:/tmp/hermes ports : - 4000:4000 - 5000:5000 volumes : hermes_volume : external : true","title":"Using Docker"},{"location":"docker-build/#running-the-image","text":"docker run -p 4000 :4000 -v $pwd /config.json:/app/config.json hermes-app The above example assumes that the TCP server has been configured to listen on port 4000. In case that is configured to another port, please configure the docker exposed port accordingly.","title":"Running the image"},{"location":"docker-build/#selinux-policies","text":"When using Docker on a host with SELinux enabled, the container is denied access to certain parts of host file system unless it is run in privileged mode. To resolve this, you can use a named volume # Create a docker volume and map it to /tmp/hermes on the host docker volume create --driver local --opt type = none --opt device = /tmp/hermes --opt o = bind hermes_volume # Ensure /tmp/hermes/config.json has the required broker configuration # Use the above created hermes_volume to mount the config file into the container docker run -p 4000 :4000 -e CONFIG_FILE_PATH = /tmp/hermes/config.json --mount source = hermes_volume,target = /tmp/hermes hermes Please note that however, you place your config.json in the /tmp directory, SELinux does not restrict you access when you use a direct volume mapping. # This won't work with SELinux enabled docker run -p 4000 :4000 -e CONFIG_FILE_PATH = /tmp/hermes/config.json -v /home/user/config.json:/tmp/hermes/config.json hermes # This will work docker run -p 4000 :4000 -e CONFIG_FILE_PATH = /tmp/hermes/config.json -v /tmp/hermes/config.json:/tmp/hermes/config.json hermes The Configuration section has more details on which attributes of the broker can be configured.","title":"SELinux policies"},{"location":"docker-build/#running-in-compose-mode","text":"Create the named volume hermes_volume . # Create a docker volume and map it to /tmp/hermes on the host docker volume create --driver local --opt type = none --opt device = /tmp/hermes --opt o = bind hermes_volume Reference the named volume for the service version : \"3.9\" services : broker : build : context : . environment : CONFIG_FILE_PATH : \"/tmp/hermes/config.json\" volumes : - hermes_volume:/tmp/hermes ports : - 4000:4000 - 5000:5000 volumes : hermes_volume : external : true","title":"Running in Compose mode"},{"location":"java/","text":"Hermes is a MQTT v5.0 compatible broker, so any compatible Java library can be used. The widely used Eclipse Paho library can be imported into any Maven or Gradle project. <repositories> <repository> <id> Eclipse Paho Repo </id> <url> https://repo.eclipse.org/content/repositories/paho-releases/ </url> </repository> </repositories> <dependencies> <dependency> <groupId> org.eclipse.paho </groupId> <artifactId> org.eclipse.paho.mqttv5.client </artifactId> <version> 1.2.5 </version> </dependency> </dependencies> For Gradle repositories, use the below // Groovy script repositories { maven { url \"https://repo.eclipse.org/content/repositories/paho-releases/\" } } // Kotlin script repositories { maven { url = uri ( \"https://repo.eclipse.org/content/repositories/paho-releases/\" ) } } Connecting to MQTT broker var persistence = new MemoryPersistence (); var client = new MqttClient ( broker , clientID , persistence ); var connOpts = new MqttConnectionOptions (); // Setting clean start to \"false\" enables the client // to receive offline messages send while it was disconnected. connOpts . setCleanStart ( false ); client . connect ( connOpts ); Publishing messages // Ensure client has already connected var content = \"Hello World\" ; var topic = \"my-topic\" ; var message = new MqttMessage ( content . getBytes ()); client . publish ( topic , message ); Subscribing to incoming messages // Do this before connecting client . setCallback ( new MqttCallback (){ @Override public void messageArrived ( String topic , MqttMessage message ) throws Exception { // Do something awesome } // other implemented methods }); client . connect ( connOpts ); // Provide a topic and Quality of Service (QoS) client . subscribe ( \"my-topic\" , 0 ); Closing the connection client . disconnect (); Spring Integration Spring Integration provides inbound and outbound channel adapters to support the MQTT protocol. The following dependencies can be used for Maven and Gradle respectively <dependency> <groupId> org.springframework.integration </groupId> <artifactId> spring-integration-mqtt </artifactId> <version> 5.4.2 </version> </dependency> compile \"org.springframework.integration:spring-integration-mqtt:5.4.2\" Inbound Channel Adapters Inbound adapters allow Spring applications to subscribe to topics and respond to incoming MQTT messages. @Bean public IntegrationFlow mqttInbound () { var broker = \"tcp://localhost:1883\" ; var clientID = \"client-id\" ; var topic = \"my-topic\" ; var adapter = new MqttPahoMessageDrivenChannelAdapter ( broker , clientID , topic ); return IntegrationFlows . from ( adapter ). handle ( m -> handleMsg ( m )). get (); } public void handleMsg ( MqttMessage message ) { // Do something awesome } Outbound Channel Adapters Inbound adapters allow Spring applications to publish MQTT messages onto topics. @Bean public IntegrationFlow mqttOutboundFlow () { var broker = \"tcp://localhost:1883\" ; var clientID = \"client-id\" ; return f -> f . handle ( new MqttPahoMessageHandler ( broker , clientID )); } More information regarding Spring MQTT integration can be found below on the Spring MQTT Support Homepage","title":"Java"},{"location":"java/#connecting-to-mqtt-broker","text":"var persistence = new MemoryPersistence (); var client = new MqttClient ( broker , clientID , persistence ); var connOpts = new MqttConnectionOptions (); // Setting clean start to \"false\" enables the client // to receive offline messages send while it was disconnected. connOpts . setCleanStart ( false ); client . connect ( connOpts );","title":"Connecting to MQTT broker"},{"location":"java/#publishing-messages","text":"// Ensure client has already connected var content = \"Hello World\" ; var topic = \"my-topic\" ; var message = new MqttMessage ( content . getBytes ()); client . publish ( topic , message );","title":"Publishing messages"},{"location":"java/#subscribing-to-incoming-messages","text":"// Do this before connecting client . setCallback ( new MqttCallback (){ @Override public void messageArrived ( String topic , MqttMessage message ) throws Exception { // Do something awesome } // other implemented methods }); client . connect ( connOpts ); // Provide a topic and Quality of Service (QoS) client . subscribe ( \"my-topic\" , 0 );","title":"Subscribing to incoming messages"},{"location":"java/#closing-the-connection","text":"client . disconnect ();","title":"Closing the connection"},{"location":"java/#spring-integration","text":"Spring Integration provides inbound and outbound channel adapters to support the MQTT protocol. The following dependencies can be used for Maven and Gradle respectively <dependency> <groupId> org.springframework.integration </groupId> <artifactId> spring-integration-mqtt </artifactId> <version> 5.4.2 </version> </dependency> compile \"org.springframework.integration:spring-integration-mqtt:5.4.2\"","title":"Spring Integration"},{"location":"java/#inbound-channel-adapters","text":"Inbound adapters allow Spring applications to subscribe to topics and respond to incoming MQTT messages. @Bean public IntegrationFlow mqttInbound () { var broker = \"tcp://localhost:1883\" ; var clientID = \"client-id\" ; var topic = \"my-topic\" ; var adapter = new MqttPahoMessageDrivenChannelAdapter ( broker , clientID , topic ); return IntegrationFlows . from ( adapter ). handle ( m -> handleMsg ( m )). get (); } public void handleMsg ( MqttMessage message ) { // Do something awesome }","title":"Inbound Channel Adapters"},{"location":"java/#outbound-channel-adapters","text":"Inbound adapters allow Spring applications to publish MQTT messages onto topics. @Bean public IntegrationFlow mqttOutboundFlow () { var broker = \"tcp://localhost:1883\" ; var clientID = \"client-id\" ; return f -> f . handle ( new MqttPahoMessageHandler ( broker , clientID )); } More information regarding Spring MQTT integration can be found below on the Spring MQTT Support Homepage","title":"Outbound Channel Adapters"},{"location":"source-build/","text":"Hermes can be built from source on Linux, Windows, or macOS. Prerequisites Git Golang 1.15 or newer Building git clone https://github.com/c16a/hermes.git cd hermes go build -ldflags = \"-s -w\" -o binary github.com/c16a/hermes/app Cross compiling To cross compile the Hermes binary to a different architecture or operating system, the GOOS and GOARCH environment variables can be used. # List all available os/arch combinations for cross compiling go tool dist list # To compile the binary for Linux ARM 64-bit, use the below GOOS = linux GOARCH = arm64 go build -ldflags = \"-s -w\" -o binary_amd64 github.com/c16a/hermes/app","title":"Building from source"},{"location":"source-build/#prerequisites","text":"Git Golang 1.15 or newer","title":"Prerequisites"},{"location":"source-build/#building","text":"git clone https://github.com/c16a/hermes.git cd hermes go build -ldflags = \"-s -w\" -o binary github.com/c16a/hermes/app","title":"Building"},{"location":"source-build/#cross-compiling","text":"To cross compile the Hermes binary to a different architecture or operating system, the GOOS and GOARCH environment variables can be used. # List all available os/arch combinations for cross compiling go tool dist list # To compile the binary for Linux ARM 64-bit, use the below GOOS = linux GOARCH = arm64 go build -ldflags = \"-s -w\" -o binary_amd64 github.com/c16a/hermes/app","title":"Cross compiling"}]}